
--- START OF FILE: .gitignore ---
# ------------------------------
# Rust / Cargo
# ------------------------------
/target/
target/
**/*.rs.bk

# Keep Cargo.lock for binaries/apps (recommended).
# If you convert this repo to a library crate and want to ignore Cargo.lock, uncomment:
# Cargo.lock

# Profiling & coverage (e.g., cargo-llvm-cov)
*.profraw
*.profdata
/target/llvm-cov/
coverage/

# ------------------------------
# Plugin / local logs
# ------------------------------
*.log
spex_debug.log

# ------------------------------
# Environment files
# ------------------------------
.env
.env.*
!.env.example

# ------------------------------
# Editors & IDEs
# ------------------------------
# VS Code
.vscode/
# JetBrains (CLion/IntelliJ/Fleet)
.idea/
*.iml
.fleet/

# ------------------------------
# OS junk
# ------------------------------
.DS_Store
.AppleDouble
.LSOverride
._*
Thumbs.db

# ------------------------------
# Python (if you keep small helper scripts around)
# ------------------------------
/.venv/
__pycache__/
*.pyc

# ------------------------------
# Archives / dumps
# ------------------------------
*.zip
*.tar
*.tar.gz
*.tgz
*.gz
*.bz2
*.xz

# ------------------------------
# Misc
# ------------------------------
*~
*.swp
*.swo
--- END OF FILE: .gitignore ---


--- START OF FILE: Cargo.toml ---
### FILE: Cargo.toml
[package]
name = "spex-rust"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "spex-rust"
path = "src/main.rs"

[dependencies]
# Async runtime
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
futures = "0.3"

# gRPC and Protobuf
tonic = "0.11"
prost = "0.12"

# Templating (Jinja2 equivalent)
tera = "1.19"

# HTTP Client for LLM calls
reqwest = { version = "0.12", features = ["json"] }

# Serialization/Deserialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# Error Handling
anyhow = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = "0.3"

# Regular Expressions for parsing LLM output
regex = "1.10"
lazy_static = "1.4"
tokio-stream = { version = "0.1.17", features = ["net"] }

[build-dependencies]
tonic-build = "0.11"

--- END OF FILE: Cargo.toml ---


--- START OF FILE: README.md ---
# spex-rust

Rust plugin for **Spex**. It launches a local `gRPC` server, prints a single handshake line to **stdout**, and renders Rust project files from Tera templates.

- Handshake (stdout): `1|1|tcp|127.0.0.1:<PORT>|grpc`
- Logs (stderr): structured with `tracing` (no logs to stdout)

---

## Prereqs

- Rust stable (edition 2021)
- `cargo`
- (Optional) Python + Poetry (to run `spex-core` locally)

---

## Build

```bash
# debug
cargo build

# release
cargo build --release
```

--- 

## Fast test of the binary:

```bash
# add local release to PATH for this shell
export PATH="$(pwd)/target/release:$PATH"

# the first stdout line should be the handshake (logs go to stderr)
spex-rust 2>/dev/null | head -1
# expected: 1|1|tcp|127.0.0.1:<PORT>|grpc
```
> If you see a “Broken pipe” after head -1: that’s an old build that logs to stdout. Rebuild; the current code logs to stderr only.

---

## Install (so spex-core can find it)

Two options—use one:

### A) Install to `~/.cargo/bin` (recommended)
```bash
cargo install --path . --force
# verify
which -a spex-rust
```

### B) Don’t install; just export PATH when running core
```bash
# from spex-core
poetry run env PATH="/abs/path/to/spex-rust/target/release:$PATH" \
  spex generate my_rust_spec.toml
```

---

## Debugging: PATH & Plugin Discovery

Core discovers the plugin by name spex-rust on its PATH.

Check what Poetry sees:
```bash
# from spex-core dir
poetry run which -a spex-rust
```
If that shows `~/.cargo/bin/spex-rust` but you want your local build, either:
    •   Install your latest (`cargo install --path . --force`), or
    •   Override PATH for that run (see option B above).

Test the binary from Poetry’s env:
```bash
poetry run bash -lc 'spex-rust 2>/dev/null | head -1'
# expect: 1|1|tcp|127.0.0.1:<PORT>|grpc
```
Remove stale binary if needed:
```bash
cargo uninstall spex-rust           # if installed by cargo
rm -f ~/.cargo/bin/spex-rust        # if it was just a stray file
hash -r
```

---

Template Gotchas (Tera)
- Default filter requires a named arg:
```
{% set pkg_name = spec.package_name | default(value="spex_app") %}
```

- Escaping examples that contain {{ ... }}:
```
{% raw %}Command::cargo_bin("{{ spec.binary_name | default(value="app") }}"){% endraw %}
```

---

## LLM Response Parsing (Rust client)

When parsing provider responses, index arrays correctly:
```rust
// OpenAI chat
data["choices"][0]["message"]["content"].as_str()

// Gemini
data["candidates"][0]["content"]["parts"][0]["text"].as_str()
```

Avoid `Result<_, String>` in the library layer; prefer `anyhow::Result` (apps) or typed errors with thiserror (libs). This keeps `.context("...")` usable at call sites.

⸻

Development Tips

# format & lint
cargo fmt --all
cargo clippy --all-targets -- -D warnings

# run unit tests (if any)
cargo test

Handshake contract:
- First line on stdout: `1|1|tcp|HOST:PORT|grpc`
- Everything else (info, warnings, errors) → `stderr`

If spex-core errors with:
- Plugin executable not found: `spex-rust` → `PATH` issue (see "Install/Using with spex-core").
- not enough values to unpack / invalid handshake → wrong binary or stdout noise before handshake (verify with head -1 test).
- Tera expected an identifier → use `default(value="...")` or escape example `{{ ... }} with {% raw %}`.

--- END OF FILE: README.md ---


--- START OF FILE: build.rs ---
// FILE: build.rs
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::compile_protos("proto/plugin.proto")?;
    Ok(())
}
--- END OF FILE: build.rs ---


--- START OF FILE: create ---
#!/usr/bin/env bash
set -euo pipefail

# Root directory for the new project
ROOT="spex-rust"

# Create directories
mkdir -p "$ROOT"/proto
mkdir -p "$ROOT"/src
mkdir -p "$ROOT"/templates/rust/instructions
mkdir -p "$ROOT"/templates/rust/patterns
mkdir -p "$ROOT"/templates/rust/prompt_templates
mkdir -p "$ROOT"/templates/shared

# Create top-level files
touch "$ROOT"/Cargo.toml
touch "$ROOT"/README.md
touch "$ROOT"/build.rs

# Create proto files
touch "$ROOT"/proto/plugin.proto

# Create source files
touch "$ROOT"/src/main.rs
touch "$ROOT"/src/server.rs
touch "$ROOT"/src/llm_client.rs
touch "$ROOT"/src/prompt_builder.rs
touch "$ROOT"/src/project_builder.rs
touch "$ROOT"/src/spec.rs

# Create template files
touch "$ROOT"/templates/rust/Cargo.toml.template
touch "$ROOT"/templates/rust/Makefile.template
touch "$ROOT"/templates/rust/main.rs.template
touch "$ROOT"/templates/rust/instructions/rust_rules.tera
touch "$ROOT"/templates/rust/patterns/cli_patterns.tera
touch "$ROOT"/templates/rust/prompt_templates/generation.tera
touch "$ROOT"/templates/rust/prompt_templates/review.tera
touch "$ROOT"/templates/shared/README.md.template
touch "$ROOT"/templates/shared/gitignore.template

echo "✅ spex-rust skeleton created successfully."
--- END OF FILE: create ---


--- START OF FILE: proto/plugin.proto ---
// proto/plugin.proto
// This file defines the gRPC service contract for all Spex language plugins.
syntax = "proto3";
package plugin;

// The SpexPlugin service is the core of the plugin system. It defines the
// set of remote procedure calls (RPCs) that the main Spex application can
// invoke on a language plugin.
service SpexPlugin {
  // GenerateProject is the primary RPC. It takes a single request containing
  // all necessary configuration and the user's specification, and it returns
  // a complete set of files for the new project.
  rpc GenerateProject(GenerateRequest) returns (GenerateResponse) {}
}

// GenerateRequest contains all the information a plugin needs to perform
// a complete code generation task. It is sent from the core Spex app to the plugin.
message GenerateRequest {
  // The full, raw content of the user's `spec.toml` file. The plugin is
  // responsible for parsing and validating this content. This keeps the
  // plugin fully decoupled from the core application's internal models.
  string spec_toml_content = 1;

  // LLMConfig contains all the necessary runtime configuration for the plugin
  // to make a call to a Large Language Model. This information is passed
  // through from the core app's settings.
  message LLMConfig {
    // The provider to use (e.g., "openai", "gemini").
    string provider = 1;
    // The specific model identifier (e.g., "gpt-4o-mini").
    string model = 2;
    // The API key for the specified provider.
    string api_key = 3;
    // The base URL for the provider's API endpoint.
    string base_url = 4;
    // The generation temperature.
    float temperature = 5;
    // The network timeout in seconds for the API request.
    int32 timeout_s = 6;
  }

  // The LLM configuration for this specific request.
  LLMConfig llm_config = 2;

  // A flag indicating whether this is the second "review" pass in a
  // two-pass generation workflow.
  bool is_review_pass = 3;

  // If `is_review_pass` is true, this field will contain the complete,
  // file-formatted code generated during the first pass.
  string initial_code = 4;
}

// File represents a single file to be created in the generated project.
message File {
  // The relative path of the file from the project root
  // (e.g., "src/main.rs" or ".gitignore").
  string path = 1;
  // The complete, raw content of the file.
  string content = 2;
}

// GenerateResponse is the message sent from the plugin back to the core Spex
// application. It contains the complete result of a generation task.
message GenerateResponse {
  // A list of all files that make up the generated project. The core
  // application will be responsible for writing these files to disk.
  repeated File files = 1;
}
--- END OF FILE: proto/plugin.proto ---


--- START OF FILE: src/llm_client.rs ---
use crate::spex_plugin::generate_request::LlmConfig;
use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use serde_json::{json, Value};
use std::time::Duration;
use tracing::info;

pub struct LlmClient {
    config: LlmConfig,
    client: Client,
}

impl LlmClient {
    pub fn new(config: LlmConfig) -> Self {
        // Build a client; request-specific timeouts set per-call below as well.
        let client = Client::new();
        Self { config, client }
    }

    pub async fn generate(&self, prompt: &str) -> Result<String> {
        let timeout = Duration::from_secs(self.config.timeout_s.max(1) as u64);
        let provider = &self.config.provider;

        let (url, payload) = match provider.as_str() {
            "openai" => (
                format!("{}/chat/completions", self.config.base_url),
                json!({
                    "model": self.config.model,
                    "messages": [{"role": "user", "content": prompt}],
                    "temperature": self.config.temperature,
                }),
            ),
            "gemini" => (
                format!(
                    "{}/models/{}:generateContent?key={}",
                    self.config.base_url, self.config.model, self.config.api_key
                ),
                json!({
                    "contents": [{"parts": [{"text": prompt}]}],
                    "generationConfig": {"temperature": self.config.temperature},
                }),
            ),
            other => return Err(anyhow!("Unsupported LLM provider: {}", other)),
        };

        info!("Sending request to {} model {}", provider, self.config.model);

        let mut builder = self.client.post(&url).timeout(timeout).json(&payload);
        if provider == "openai" {
            builder = builder.bearer_auth(&self.config.api_key);
        }

        let response = builder.send().await?.error_for_status()?;
        let response_json: Value = response.json().await?;

        self.parse_response(provider, &response_json)
    }

    fn parse_response(&self, provider: &str, data: &Value) -> Result<String> {
        let text = match provider {
            // Correctly index arrays
            "openai" => data["choices"][0]["message"]["content"].as_str(),
            "gemini" => data["candidates"][0]["content"]["parts"][0]["text"].as_str(),
            _ => None,
        };

        text.map(String::from)
            .context(format!("Failed to parse LLM response for {}", provider))
    }
}
--- END OF FILE: src/llm_client.rs ---


--- START OF FILE: src/main.rs ---
use std::net::SocketAddr;
use tokio_stream::wrappers::TcpListenerStream;
use tonic::transport::Server;

mod llm_client;
mod project_builder;
mod prompt_builder;
mod server;
mod spec;

use server::RustPluginServicer;

pub mod spex_plugin {
    tonic::include_proto!("plugin");
}
use spex_plugin::spex_plugin_server::SpexPluginServer;

fn install_panic_hook() {
    std::panic::set_hook(Box::new(|info| {
        eprintln!("panic: {info}");
        if let Some(loc) = info.location() {
            eprintln!("at: {}:{}", loc.file(), loc.line());
        }
    }));
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // stderr logging; keep stdout clean for handshake
    tracing_subscriber::fmt().with_writer(std::io::stderr).init();
    install_panic_hook();

    // Bind to an ephemeral port on loopback
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await?;
    let addr: SocketAddr = listener.local_addr()?;

    // Handshake to stdout (required by spex-core)
    println!("1|1|tcp|{}:{}|grpc", addr.ip(), addr.port());

    // Build and run gRPC server
    let plugin_service = RustPluginServicer::new()?;
    let server = SpexPluginServer::new(plugin_service);

    Server::builder()
        .add_service(server)
        .serve_with_incoming(TcpListenerStream::new(listener))
        .await?;

    Ok(())
}
--- END OF FILE: src/main.rs ---


--- START OF FILE: src/project_builder.rs ---
//! Packaging of generated files and rendered infrastructure templates.
//! - Parses ### FILE: blocks by header scanning (no look-around).
//! - Sanitizes non-markdown outputs (strip accidental fences / headers).
//! - Normalizes paths (no absolute, no parent traversal), skips templates/.
//! - Renders infra from a list of candidate template names and falls back
//!   to a built-in .gitignore if none found.

use crate::{
    spec::SpexSpecification,
    spex_plugin::{File, GenerateResponse},
};
use anyhow::{anyhow, Context, Result};
use lazy_static::lazy_static;
use regex::Regex;
use std::borrow::Cow;
use std::collections::HashSet;
use std::path::{Component, Path};
use tera::{Context as TeraContext, Tera};
use tracing::{debug, info, warn};

lazy_static! {
    /// `### FILE: path/to/file.ext`
    static ref FILE_HEADER_RE: Regex =
        Regex::new(r"(?m)^###\s*FILE:\s*(?P<path>[^\r\n]+)\s*\r?$")
            .expect("valid FILE_HEADER_RE");

    /// Entire file fenced in ```lang ... ```
    static ref FULL_FENCE_RE: Regex =
        Regex::new(r"(?s)^\s*```[a-zA-Z0-9_-]*\s*\r?\n(.*)\r?\n```\s*$")
            .expect("valid FULL_FENCE_RE");

    /// Remove a leading `### FILE:` line inside a file if present
    static ref FILE_MARKER_RE: Regex =
        Regex::new(r"(?m)^\s*###\s+FILE:.*\r?\n")
            .expect("valid FILE_MARKER_RE");

    /// UTF-8 BOM
    static ref LEADING_BOM_RE: Regex =
        Regex::new(r"^\u{FEFF}")
            .expect("valid LEADING_BOM_RE");
}

fn is_markdown_like(path: &str) -> bool {
    let p = path.to_ascii_lowercase();
    p.ends_with(".md") || p.ends_with(".markdown") || p.ends_with(".rst")
}

fn normalize_newlines(s: &str) -> Cow<'_, str> {
    if !s.as_bytes().contains(&b'\r') {
        Cow::Borrowed(s)
    } else {
        Cow::Owned(s.replace("\r\n", "\n").replace('\r', "\n"))
    }
}

fn strip_bom(s: &str) -> Cow<'_, str> {
    if LEADING_BOM_RE.is_match(s) {
        Cow::Owned(LEADING_BOM_RE.replace(s, "").into_owned())
    } else {
        Cow::Borrowed(s)
    }
}

fn strip_leading_file_marker(s: &str) -> Cow<'_, str> {
    if FILE_MARKER_RE.is_match(s) {
        Cow::Owned(FILE_MARKER_RE.replace(s, "").into_owned())
    } else {
        Cow::Borrowed(s)
    }
}

fn strip_full_file_fence(s: &str) -> Option<String> {
    FULL_FENCE_RE
        .captures(s)
        .and_then(|cap| cap.get(1).map(|m| m.as_str().to_string()))
}

/// For non-markdown files:
/// - strip a single leading "### FILE:" header if present
/// - strip a single surrounding ``` fence if the *whole* file is fenced
/// Always drop BOM & normalize newlines.
fn sanitize_nonmarkdown_output(path: &str, content: &str) -> String {
    let content = strip_bom(content);
    let content = normalize_newlines(&content);

    if is_markdown_like(path) {
        return content.into_owned();
    }

    let no_marker = strip_leading_file_marker(&content).into_owned();
    if let Some(inner) = strip_full_file_fence(&no_marker) {
        normalize_newlines(&inner).into_owned()
    } else {
        no_marker
    }
}

/// Return `Some(sanitized_path)` if acceptable (no absolute, no `..`, not under templates/).
fn sanitize_path(path: &str) -> Option<String> {
    let mut p = path.replace('\\', "/").trim().to_string();
    if p.is_empty() { return None; }
    if let Some(stripped) = p.strip_prefix("./") { p = stripped.to_string(); }
    if Path::new(&p).is_absolute() { return None; }
    if p.starts_with("templates/") { return None; }
    let has_traversal = Path::new(&p)
        .components()
        .any(|c| matches!(c, Component::ParentDir));
    if has_traversal { return None; }
    Some(p)
}

fn upsert_file(response: &mut GenerateResponse, path: String, content: String) {
    if let Some(idx) = response.files.iter().position(|f| f.path == path) {
        debug!("Replacing existing file: {}", path);
        response.files[idx].content = content;
    } else {
        response.files.push(File { path: path.clone(), content });
        debug!("Packaged code file: {}", path);
    }
}

/// Parse `### FILE:` blocks by index slicing (no look-arounds).
fn slice_file_blocks(llm_output: &str) -> Vec<(String, String)> {
    let mut blocks = Vec::new();

    let headers: Vec<(usize, usize, String)> = FILE_HEADER_RE
        .captures_iter(llm_output)
        .filter_map(|cap| {
            let m = cap.get(0)?;
            let start = m.start();
            let end = m.end();
            let raw_path = cap.name("path")?.as_str().trim().to_string();
            Some((start, end, raw_path))
        })
        .collect();

    if headers.is_empty() { return blocks; }

    let total_len = llm_output.len();
    for i in 0..headers.len() {
        let (_h_start, h_end, raw_path) = &headers[i];
        let content_start = *h_end;
        let next_start = if i + 1 < headers.len() { headers[i + 1].0 } else { total_len };

        if let Some(path) = sanitize_path(raw_path) {
            let mut slice = &llm_output[content_start..next_start];
            if let Some(stripped) = slice.strip_prefix("\r\n") {
                slice = stripped;
            } else if let Some(stripped) = slice.strip_prefix('\n') {
                slice = stripped;
            }
            let cleaned = sanitize_nonmarkdown_output(&path, slice);
            blocks.push((path, cleaned));
        } else {
            warn!("Skipping invalid or disallowed path in LLM output: {}", raw_path);
        }
    }
    blocks
}

/// Extract code blocks from LLM output and package them as files.
/// Returns number of files packaged.
pub fn package_code_files(llm_output: &str, response: &mut GenerateResponse) -> usize {
    let blocks = slice_file_blocks(llm_output);
    let count = blocks.len();
    for (path, content) in blocks {
        upsert_file(response, path, content);
    }
    if count == 0 {
        warn!("No code files matched the expected '### FILE:' block format.");
    } else {
        info!("Total packaged code files: {}", count);
    }
    count
}

/// Built-in .gitignore fallback content (used only if no template is found).
fn default_gitignore() -> &'static str {
    r#"# Rust / Cargo
/target/
**/*.rs.bk

# Editors & IDEs
.vscode/
.idea/
*.iml

# OS junk
.DS_Store
Thumbs.db

# Coverage / profiling
*.profraw
*.profdata
/target/llvm-cov/
coverage/

# Python (if present)
/.venv/
__pycache__/
*.pyc
"#
}

/// Render the first existing template from `candidates`.
fn render_first_existing(tera: &Tera, candidates: &[&str], ctx: &TeraContext) -> Result<String> {
    let names: HashSet<_> = tera.get_template_names().collect();
    for &name in candidates {
        if names.contains(name) {
            return tera.render(name, ctx).with_context(|| format!("Failed to render template: {}", name));
        }
    }
    Err(anyhow!("None of the candidate templates exist: {}", candidates.join(", ")))
}

/// Render infrastructure templates (Cargo.toml, Makefile, README, .gitignore).
/// Try multiple candidate names per file; fall back to built-in .gitignore if needed.
pub fn package_infrastructure_files(
    tera: &Tera,
    spec: &SpexSpecification,
    response: &mut GenerateResponse,
) -> Result<()> {
    info!("Packaging infrastructure files...");
    let mut ctx = TeraContext::new();
    ctx.insert("spec", spec);
    for (key, value) in &spec.extras {
        ctx.insert(key, value);
    }

    // For each output path, list candidate template names (first existing will be used)
    let plan: Vec<(&str, Vec<&str>)> = vec![
        ("Cargo.toml", vec![
            "rust/Cargo.toml.template",
            "rust/Cargo.toml.tera",
            "shared/Cargo.toml.template",
            "shared/Cargo.toml.tera",
        ]),
        ("Makefile", vec![
            "rust/Makefile.template",
            "rust/Makefile.tera",
            "shared/Makefile.template",
            "shared/Makefile.tera",
        ]),
        ("README.md", vec![
            "rust/README.md.template",
            "rust/README.md.tera",
            "shared/README.md.template",
            "shared/README.md.tera",
        ]),
        (".gitignore", vec![
            "rust/gitignore.template",
            "rust/gitignore.tera",
            "shared/gitignore.template",
            "shared/gitignore.tera",
        ]),
    ];

    for (out_path, candidates) in plan {
        let rendered = if out_path == ".gitignore" {
            match render_first_existing(tera, &candidates, &ctx) {
                Ok(s) => s,
                Err(e) => {
                    warn!("{} — using built-in default .gitignore", e);
                    default_gitignore().to_string()
                }
            }
        } else {
            render_first_existing(tera, &candidates, &ctx)?
        };

        let content = sanitize_nonmarkdown_output(out_path, &rendered);
        upsert_file(response, out_path.to_string(), content);
        info!("Packaged infrastructure file: {}", out_path);
    }

    Ok(())
}

/// Bootstrap a minimal compilable project if the LLM returned no code files.
/// Returns number of files rendered.
pub fn package_bootstrap_files(
    tera: &Tera,
    spec: &SpexSpecification,
    response: &mut GenerateResponse,
) -> Result<usize> {
    info!("Bootstrapping minimal project for project_type='{}'", spec.project_type);
    let mut ctx = TeraContext::new();
    ctx.insert("spec", spec);
    for (key, value) in &spec.extras {
        ctx.insert(key, value);
    }

    let pt = spec.project_type.to_ascii_lowercase();
    let files: Vec<(String, &'static str)> = match pt.as_str() {
        "service" => vec![
            ("src/main.rs".into(),   "rust/bootstrap/service/main.rs.tera"),
            ("src/lib.rs".into(),    "rust/bootstrap/service/lib.rs.tera"),
            ("src/routes.rs".into(), "rust/bootstrap/service/routes.rs.tera"),
            ("tests/health.rs".into(),"rust/bootstrap/service/tests_health.rs.tera"),
        ],
        "library" => vec![
            ("src/lib.rs".into(),    "rust/bootstrap/library/lib.rs.tera"),
            ("tests/lib.rs".into(),  "rust/bootstrap/library/tests_lib.rs.tera"),
        ],
        _ => vec![
            ("src/main.rs".into(),   "rust/bootstrap/cli/main.rs.tera"),
            ("src/lib.rs".into(),    "rust/bootstrap/cli/lib.rs.tera"),
            ("tests/cli.rs".into(),  "rust/bootstrap/cli/tests_cli.rs.tera"),
        ],
    };

    let names: HashSet<_> = tera.get_template_names().collect();
    let mut rendered_count = 0usize;
    for (path, tpl) in files {
        if !names.contains(tpl) {
            warn!("Bootstrap template missing: {}", tpl);
            continue;
        }
        let rendered = tera.render(tpl, &ctx)
            .with_context(|| format!("Failed to render bootstrap template: {}", tpl))?;
        let content = sanitize_nonmarkdown_output(&path, &rendered);
        upsert_file(response, path, content);
        rendered_count += 1;
    }

    info!("Bootstrapped {} file(s).", rendered_count);
    Ok(rendered_count)
}
--- END OF FILE: src/project_builder.rs ---


--- START OF FILE: src/prompt_builder.rs ---
// FILE: src/prompt_builder.rs
use crate::{spec::SpexSpecification, spex_plugin::GenerateRequest};
use anyhow::{Context, Result};
use tera::{Context as TeraContext, Tera};

pub fn render_prompt(
    tera: &Tera,
    spec: &SpexSpecification,
    request: &GenerateRequest,
) -> Result<String> {
    let template_type = if request.is_review_pass { "review" } else { "generation" };
    let template_path = format!("rust/prompt_templates/{}.tera", template_type);

    let mut context = TeraContext::new();
    context.insert("spec", spec);

    // Make extras (like [[features]]) available at *top-level* in templates,
    // mirroring what project_builder does for infra templates.
    for (key, value) in &spec.extras {
        context.insert(key, value);
    }

    if request.is_review_pass {
        context.insert("initial_code", &request.initial_code);
    }

    tera.render(&template_path, &context)
        .context(format!("Failed to render template: {}", template_path))
}
--- END OF FILE: src/prompt_builder.rs ---


--- START OF FILE: src/server.rs ---
use crate::{llm_client::LlmClient, project_builder, prompt_builder, spec::SpexSpecification};
use futures::FutureExt;
use serde_json::json;
use std::backtrace::Backtrace;
use std::collections::HashSet;
use tera::Tera;
use tonic::{Request, Response, Status};
use tracing::{error, info};

use crate::spex_plugin::{spex_plugin_server::SpexPlugin, GenerateRequest, GenerateResponse};

pub struct RustPluginServicer {
    tera: Tera,
}

impl RustPluginServicer {
    pub fn new() -> anyhow::Result<Self> {
        let pattern = format!("{}/templates/**/*", env!("CARGO_MANIFEST_DIR"));
        let mut tera = Tera::new(&pattern)?;
        tera.autoescape_on(vec![]);
        info!("Tera template environment loaded (pattern: {pattern})");

        // Log what Tera sees (helps diagnose naming mismatches)
        let names: Vec<_> = tera.get_template_names().collect();
        info!("Loaded {} templates: {:?}", names.len(), names);

        // Fail fast if core infra templates are missing (we’ll fallback only for .gitignore)
        ensure_required_templates(&tera)?;

        Ok(Self { tera })
    }

    async fn handle_generate(&self, req: GenerateRequest) -> Result<GenerateResponse, Status> {
        info!("Received GenerateProject request.");

        let spec: SpexSpecification = toml::from_str(&req.spec_toml_content).map_err(|e| {
            error!("Failed to parse spec.toml content: {}", e);
            Status::invalid_argument(format!("Invalid spec.toml: {}", e))
        })?;

        let llm_config = req.llm_config.clone().ok_or_else(|| {
            error!("LLMConfig is missing from the request.");
            Status::invalid_argument("LLMConfig is required")
        })?;

        let llm_client = LlmClient::new(llm_config);

        let prompt = prompt_builder::render_prompt(&self.tera, &spec, &req).map_err(|e| {
            error!("Failed to render generation prompt: {:?}", e);
            Status::internal(format!("Failed to render prompt: {e:#}"))
        })?;

        let llm_output = llm_client.generate(&prompt).await.map_err(|e| {
            error!("LLM generation failed: {:?}", e);
            Status::internal(format!("LLM generation failed: {e:#}"))
        })?;

        let mut response = GenerateResponse::default();
        let code_count = project_builder::package_code_files(&llm_output, &mut response);

        project_builder::package_infrastructure_files(&self.tera, &spec, &mut response).map_err(
            |e| {
                error!("Failed to package infrastructure files: {:?}", e);
                Status::internal(format!("Failed to package infrastructure files: {e:#}"))
            },
        )?;

        if code_count == 0 {
            info!("No code files from LLM; rendering bootstrap skeleton");
            project_builder::package_bootstrap_files(&self.tera, &spec, &mut response).map_err(
                |e| {
                    error!("Failed to package bootstrap files: {:?}", e);
                    Status::internal(format!("Failed to package bootstrap files: {e:#}"))
                },
            )?;
        }

        // append manifest
        let manifest = json!({
            "files": response.files.iter().map(|f| json!({"path": f.path})).collect::<Vec<_>>()
        }).to_string();
        response.files.push(crate::spex_plugin::File { path: ".spex_manifest.json".into(), content: manifest });

        Ok(response)
    }
}

fn ensure_required_templates(tera: &Tera) -> anyhow::Result<()> {
    use anyhow::anyhow;
    let required: &[&str] = &[
        // we’ll fallback for .gitignore so it’s not required here
        "rust/Cargo.toml.template",
        "rust/Makefile.template",
        "rust/README.md.template",
        "rust/instructions/rust_rules.tera",
        "rust/prompt_templates/generation.tera",
        "rust/prompt_templates/review.tera",
    ];

    let names: HashSet<_> = tera.get_template_names().collect();
    let mut missing = Vec::new();
    for t in required {
        if !names.contains(*t) {
            missing.push(*t);
        }
    }
    if !missing.is_empty() {
        return Err(anyhow!("Missing required templates: {}", missing.join(", ")));
    }
    Ok(())
}

#[tonic::async_trait]
impl SpexPlugin for RustPluginServicer {
    async fn generate_project(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResponse>, Status> {
        let fut = async { self.handle_generate(request.into_inner()).await };
        match std::panic::AssertUnwindSafe(fut).catch_unwind().await {
            Ok(Ok(resp)) => Ok(Response::new(resp)),
            Ok(Err(status)) => Err(status),
            Err(panic) => {
                let msg = if let Some(s) = panic.downcast_ref::<&str>() {
                    (*s).to_string()
                } else if let Some(s) = panic.downcast_ref::<String>() {
                    s.clone()
                } else {
                    "unknown panic payload".to_string()
                };
                let bt = Backtrace::force_capture();
                error!("panic in generate_project: {msg}\nBacktrace:\n{bt}");
                Err(Status::internal(format!(
                    "plugin panic in generate_project: {msg}\n{bt}"
                )))
            }
        }
    }
}
--- END OF FILE: src/server.rs ---


--- START OF FILE: src/spec.rs ---
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Project specification (top-level).
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SpexSpecification {
    pub language: String,

    #[serde(rename = "project_type")]
    pub project_type: String,

    pub description: String,

    pub project: Project,

    #[serde(flatten)]
    pub extras: HashMap<String, Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Project {
    pub name: String,
    pub version: String,
    pub description: String,
}
--- END OF FILE: src/spec.rs ---


--- START OF FILE: templates/rust/.gitignore.template ---
# ------------------------------
# Rust / Cargo
# ------------------------------
/target/
target/
**/*.rs.bk

# Keep Cargo.lock for binaries/apps (recommended).
# If you convert this repo to a library crate and want to ignore Cargo.lock, uncomment:
# Cargo.lock

# Profiling & coverage (e.g., cargo-llvm-cov)
*.profraw
*.profdata
/target/llvm-cov/
coverage/

# ------------------------------
# Plugin / local logs
# ------------------------------
*.log
spex_debug.log

# ------------------------------
# Environment files
# ------------------------------
.env
.env.*
!.env.example

# ------------------------------
# Editors & IDEs
# ------------------------------
# VS Code
.vscode/
# JetBrains (CLion/IntelliJ/Fleet)
.idea/
*.iml
.fleet/

# ------------------------------
# OS junk
# ------------------------------
.DS_Store
.AppleDouble
.LSOverride
._*
Thumbs.db

# ------------------------------
# Python (if you keep small helper scripts around)
# ------------------------------
/.venv/
__pycache__/
*.pyc

# ------------------------------
# Archives / dumps
# ------------------------------
*.zip
*.tar
*.tar.gz
*.tgz
*.gz
*.bz2
*.xz

# ------------------------------
# Misc
# ------------------------------
*~
*.swp
*.swo
--- END OF FILE: templates/rust/.gitignore.template ---


--- START OF FILE: templates/rust/Cargo.toml.template ---
```toml
### FILE: templates/rust/Cargo.toml.template
[package]
name = "{{ spec.project.name }}"
version = "{{ spec.project.version }}"
edition = "2021"

[dependencies]
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"
```
--- END OF FILE: templates/rust/Cargo.toml.template ---


--- START OF FILE: templates/rust/Makefile.template ---
### FILE: templates/rust/Makefile.template
.PHONY: help build run test clean

help:
	@echo "Available commands:"
	@echo "  build   - Build the project in release mode"
	@echo "  run     - Run the project"
	@echo "  test    - Run tests"
	@echo "  clean   - Clean the project"

build:
	cargo build --release

run:
	cargo run

test:
	cargo test

clean:
	cargo clean
--- END OF FILE: templates/rust/Makefile.template ---


--- START OF FILE: templates/rust/README.md.template ---
# {{ spec.project.name }}
{{ spec.project.description }}

This project was automatically generated by Spex. It contains a complete, runnable, and tested software project scaffolded according to modern best practices for the {{ spec.language }} language.

## Overview

Goal: {{ spec.description }}

Language: {{ spec.language }}

Project Type: {{ spec.project_type }}

## Getting Started
This project includes a Makefile to simplify common development tasks.

### 1. Setup the Environment

First, ensure you have the necessary toolchain for {{ spec.language }} installed on your system. Then, set up the project environment:bash

This command will install dependencies, compile code, etc.
```
make setup
```

### 2. Run the Application

Execute the main application with the default run command:

```bash
# This will run the primary executable or script.
make run
```

### 3. Run Tests

To verify the correctness of the implementation, run the test suite:

```
make test
```

Project Structure
```
.
├── src/                  # Source code for the application/library
├── tests/                # Unit and integration tests
├── Makefile              # Commands for building, running, and testing
├──.gitignore            # Standard git ignore file
└── README.md             # This file
```

## Core Logic

The primary business logic is driven by the following requirements defined in the original specification:

{% for feature in features | default(value=[]) %}
{{ feature.name }} — {{ feature.description }}
{% endfor %}

This project was generated by Spex.

--- END OF FILE: templates/rust/README.md.template ---


--- START OF FILE: templates/rust/instructions/rust_rules.tera ---
# Rust Project Rules (Generalized)

A generalized, production-friendly rule set you can apply across CLI apps, services, and libraries. Includes best practices, structure patterns, and baked‑in fixes for common pitfalls we just debugged.

---

## ✅ Global Best Practices

- **Edition & MSRV**
  - Target `edition = "2021"` (or the repo’s declared edition).
  - Keep compatibility with the project’s Minimum Supported Rust Version (MSRV) if specified.

- **Error Handling**
  - **Applications (bins):** Use `anyhow::Result<T>` and `anyhow::Context` at the edges (e.g., `main` and top-level orchestrators).
  - **Libraries:** Prefer _typed errors_ with `thiserror`. Do **not** return `Result<T, String>`; ensure the error type implements `std::error::Error`.

- **No Panics in Normal Operation**
  - Avoid `.unwrap()`/`.expect()` in library code and user paths.
  - Propagate failures using `?` and convert/annotate with `Context` at boundaries.

- **Ownership & Performance**
  - Prefer borrowing (`&str`, `&[T]`, `&T`) over cloning.
  - Use iterators and combinators; pre‑allocate where helpful (e.g., `with_capacity`).

- **Logging & Observability**
  - Use `tracing` + `tracing-subscriber`.
  - **Logs go to stderr** by default; reserve **stdout** for program output or machine‑readable protocols (e.g., handshakes).

- **Formatting & Lints**
  - Enforce `rustfmt` and `clippy` in CI (`clippy -D warnings`).
  - Keep code idiomatic and warning‑free.

- **Docs**
  - Write `rustdoc` for public items.
  - Provide crate‑level docs with purpose, usage, and examples.

- **Testing**
  - Unit tests in `#[cfg(test)]` modules.
  - Integration tests in `tests/`.
  - For CLIs/services, use `assert_cmd` to run binaries and `predicates`/`insta` for output assertions or snapshots.
  - Consider `proptest`/`quickcheck` for property‑based tests where sensible.

- **Serialization**
  - Prefer strongly typed structs with `serde`.
  - If you must use `serde_json::Value`, **validate array/object shapes** and handle missing keys safely.

- **Feature Flags**
  - Keep optional deps behind `features`. Provide sensible defaults; document feature implications.

- **Cross‑platform**
  - Use `std::path::Path`/`PathBuf`; avoid hard‑coded separators.
  - Use `dirs`/`dirs-next` for platform‑specific directories.

- **Security**
  - Validate untrusted input; avoid shelling out (`Command` with explicit args is safer).
  - Use vetted crates for crypto (e.g., `ring`, `sha2`).

---

## ✅ Project Structure Patterns (choose what fits the spec)

- **Library crate**
  - `src/lib.rs` only. Expose a small, well‑documented API.
  - Use typed errors via `thiserror`.

- **Binary + Library**
  - Thin `src/main.rs` that calls into `lib` (`use <crate_name>::...`).
  - Keep business logic in the library for testability.

- **Service (async)**
  - Use `tokio` runtime; avoid blocking in async contexts.
  - Implement graceful shutdown on `SIGINT/SIGTERM`.
  - Provide health/readiness endpoints and structured logs.

- **CLI**
  - Use `clap` derive. Split subcommands into modules (e.g., `src/commands/*.rs`).
  - Validate arguments with `clap` validators and types.

- **WASM / `no_std`**
  - Respect environment constraints; gate features and avoid unsupported APIs.

---

## NON‑NEGOTIABLE REQUIREMENTS

1. **Clear Error Types**
   - **Apps:** `fn main() -> anyhow::Result<()>`.
   - **Libs:** No `Result<_, String>`. Use `thiserror` (preferred) or ensure your error implements `Error`.

2. **No Early Stdout Noise**
   - Never print logs/banners to **stdout** before machine‑readable output (e.g., protocol handshakes). Use **stderr** for logs.

3. **Separation of Concerns**
   - If a binary exists, it must be a thin wrapper that calls into a properly structured library.

4. **Tests Must Build & Run**
   - If tests reference a binary by name, define it via `[[bin]]` in `Cargo.toml` and include required dev‑dependencies.

---

## Project‑Type Guidance

### If `project_type` == `"cli"`
- **Parsing:** Use `clap = { version = "4", features = ["derive"] }`.
- **Binary naming:** {% raw %}If tests call `Command::cargo_bin("{{ spec.binary_name | default("app") }}")`, add:{% endraw %}

{% raw %}
```toml
[[bin]]
name = "{{ spec.binary_name | default("app") }}"
path = "src/main.rs"
```
{% endraw %}

* **Dev‑deps for tests:**

{% raw %}
```toml
[dev-dependencies]
assert_cmd = "2"
predicates = "3"
```
{% endraw %}

### If writing a service (e.g. gRPC/HTTP/worker)

* Runtime: `tokio` (multi‑threaded).
* HTTP: `axum`/`hyper`; gRPC: `tonic`.
* **Graceful shutdown:** listen for `SIGINT/SIGTERM`, drain tasks, close listeners.
* **Config:** Use `config`/`dotenvy`; validate config structs.
* **Health & Metrics:** `/healthz` endpoint; emit metrics and tracing spans.

### If writing a library:

* Public API documented with examples.
* Typed errors via `thiserror`; no panics as part of the API contract.
* Avoid leaking concrete dependency types in public signatures when possible.

### If project is a wasm or constrained

* Gate non‑portable code with features.
* Avoid blocking APIs; prefer async and message passing.

---

## Common Pitfalls & How to Avoid Them

* **Binary importing lib incorrectly**

  * In `src/main.rs`, import from the library using the crate name (package name with `-`→`_`):

{% raw %}
```rust
use spex_vcs::commands; // ✅ not `use crate::commands;` in the bin
```
{% endraw %}

* **`anyhow::Context` on `Result<(), String>` (E0599)**

  * Don’t return `String` errors. Either:

    * Return `anyhow::Result<()>` from library functions, **or**
    * Define a `thiserror` enum and return `Result<T, YourError>`.

* **Binary name mismatch in tests**

  * If tests call `cargo_bin("my_cli")`, ensure:

{% raw %}
```toml
[[bin]]
name = "my_cli"
path = "src/main.rs"
```
{% endraw %}

* **Logs pollute stdout / break handshakes**

  * Route logs to **stderr**:

{% raw %}
```rust
tracing_subscriber::fmt().with_writer(std::io::stderr).init();
// eprintln!("...") is also fine for simple cases
```
{% endraw %}

* **Ad‑hoc JSON indexing errors**

  * Prefer typed structs with `serde`.
  * If using `serde_json::Value`, correctly index arrays and validate shape:

{% raw %}
```rust
let content = data["choices"][0]["message"]["content"]
    .as_str()
    .ok_or_else(|| anyhow::anyhow!("missing content"))?;
```
{% endraw %}

* **Template/spec key drift**

  * Keep variables consistent. Use `{{ spec.project_type }}` (not `analysis_type`).
  * Add a simple template render test in CI to catch mismatches early.

* **Missing dev‑deps for CLI tests**

{% raw %}
```toml
[dev-dependencies]
assert_cmd = "2"
predicates = "3"
```
{% endraw %}

* **Blocking in async services**

  * Wrap blocking work with `tokio::task::spawn_blocking` or use async equivalents.

---

## Code Sketches the Generator Should Emit (when applicable)

**Binary entry (CLI/service):**

{% raw %}
```rust
// src/main.rs
use anyhow::{Context, Result};

fn main() -> Result<()> {
    // initialize logging to stderr
    tracing_subscriber::fmt().with_writer(std::io::stderr).init();

    // thin wrapper that calls into lib
    spex_vcs::run().context("app failed")?;
    Ok(())
}
```
{% endraw %}

**Library error pattern:**
{% raw %}
```rust
// src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("invalid input: {0}")]
    InvalidInput(String),
    #[error(transparent)]
    Io(#[from] std::io::Error),
}
```
{% endraw %}

**Library API returning typed errors:**
{% raw %}
```rust
// src/lib.rs
pub mod error;
use error::AppError;

/// Entry point for the application/library.
pub fn run() -> Result<(), AppError> {
    // ... business logic ...
    Ok(())
}
```
{% endraw %}
**Cargo (when tests spawn a named bin):**
{% raw %}
```toml
[package]
name = "{{ spec.package_name | default("app") }}"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1"
tracing = "0.1"
tracing-subscriber = "0.3"
# plus `clap = { version = "4", features = ["derive"] }` for CLIs
# plus async stack for services when needed

[[bin]]
name = "{{ spec.binary_name | default("app") }}"
path = "src/main.rs"

[dev-dependencies]
assert_cmd = "2"
predicates = "3"
```
{% endraw %}
---

## Deliverables Expected from the Generator

* Correct crate layout for the `project_type` (library, binary+library, service, etc.).
* Compiles without warnings on `stable`.
* Tests pass (`cargo test`). If a CLI/service, include at least one integration test spawning the bin.
* `README.md` matches actual Makefile/Cargo tasks (don’t document `make setup` unless it exists).
* No stdout output before required machine‑readable handshake/protocol messages.

--- END OF FILE: templates/rust/instructions/rust_rules.tera ---


--- START OF FILE: templates/rust/main.rs.template ---
// FILE: templates/rust/main.rs.template
use anyhow::Result;
use clap::Parser;

/// {{ spec.project.description }}

#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long)]
    name: String,
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    println!("Hello, {}!", cli.name);
    Ok(())
}
--- END OF FILE: templates/rust/main.rs.template ---


--- START OF FILE: templates/rust/patterns/cli_patterns.tera ---
```rust
### FILE: templates/rust/patterns/cli_patterns.tera
**✅ GOOD: Using `clap` for argument parsing and `anyhow` for error handling.**
```rust
// src/main.rs
use anyhow::{Context, Result};
use clap::{Parser, Subcommand};

/// A fictional versioning CLI
#
#[clap(name = "git", version)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,
}

#
enum Commands {
    /// Add a file
    #[clap(arg_required_else_help = true)]
    Add {
        /// The path to the file to add
        path: std::path::PathBuf,
    },
    /// Commit changes
    #[clap(arg_required_else_help = true)]
    Commit {
        /// The commit message
        #[clap(short, long)]
        message: String,
    },
}

fn main() -> Result<()> {
    let args = Cli::parse();
    match args.command {
        Commands::Add { path } => {
            println!("Adding file: {}", path.display());
            // Business logic here...
        }
        Commands::Commit { message } => {
            println!("Committing with message: {}", message);
            // Business logic here...
        }
    }
    Ok(())
}
✅ GOOD: Writing integration tests for the CLI using assert_cmd.

Rust
// tests/cli.rs
use assert_cmd::prelude::*;
use std::process::Command;

#[test]
fn test_add_command() {
    let mut cmd = Command::cargo_bin("my_cli").unwrap();
    cmd.arg("add").arg("test.txt");
    cmd.assert()
       .success()
       .stdout(predicates::str::contains("Adding file: test.txt"));
}
--- END OF FILE: templates/rust/patterns/cli_patterns.tera ---


--- START OF FILE: templates/rust/prompt_templates/generation.tera ---
{# Minimal, strict generator. Avoids example FILE blocks so the model can't parrot them. #}

{# ---- Import rules ---- #}
{% include "rust/instructions/rust_rules.tera" %}

{# ---- Defaults ---- #}
{% set pkg_name = spec.package_name | default(value="spex_app") %}
{% set bin_name = spec.binary_name  | default(value=pkg_name) %}
{% set pt       = spec.project_type | default(value="cli") %}

{# ---- Hard requirements (instructions only; NOT to be echoed) ---- #}
{#
OUTPUT CONTRACT (DO NOT ECHO THIS SECTION):
- Begin output immediately with a "### FILE: <path>" line. No prose, no headings.
- Emit as many files as are needed for a complete, runnable project.
- Emit 100% of the content for each file (no placeholders).
- Minimum file set by project_type:

  CLI:
    - Cargo.toml
    - src/main.rs
    - src/lib.rs (if any non-trivial logic)
    - README.md
    - .gitignore
    - Makefile
    - tests/cli.rs (integration tests if there is a binary)

  SERVICE:
    - Cargo.toml
    - src/main.rs
    - src/lib.rs (business logic)
    - src/routes.rs or src/service.rs (as appropriate)
    - README.md
    - .gitignore
    - Makefile
    - tests/*

  LIBRARY:
    - Cargo.toml
    - src/lib.rs
    - README.md
    - .gitignore
    - Makefile
    - examples/*
    - tests/*

- You MUST also emit a final file:
    ### FILE: .spex_manifest.json
  JSON with an array of all file paths you generated plus brief reasons for inclusion. Example:
    {"files":[{"path":"Cargo.toml","why":"crate manifest"}]}
- Never echo instructions/headings like "### RESPONSE FORMAT ###".
- Always wrap file contents in ``` fences. The parser expects this.
#}

{# ---- User spec (for the model to consume) ---- #}
USER SPECIFICATION

Target Language: {{ spec.language }}
Project Type: {{ pt }}
Package Name: {{ pkg_name }}
Binary Name: {{ bin_name }}
Project Description: {{ spec.description }}

Core Features to Implement:
{% for feature in features | default(value=[]) %}
- Feature: {{ feature.name }}
  Description: {{ feature.description }}
{% endfor %}

{# ---- Generation task ---- #}
TASK

Generate a complete, runnable Rust {{ pt }} project that compiles on stable (edition = "2021") and passes `cargo test`. Apply the imported rules strictly.

STRUCTURE & MINIMUM FILES

- Choose the correct structure and dependencies for {{ pt }}.
- At minimum, include all files required by {{ pt }} (see OUTPUT CONTRACT above).
- Add any additional modules/files needed to keep `main.rs` thin and library logic testable.

CONSTRAINTS

- No `.unwrap()`/`.expect()` in normal paths.
- Logs to stderr, keep stdout clean.
- If tests refer to a specific binary name, define it via `[[bin]]` in `Cargo.toml` (name = "{{ bin_name }}").
- README/Makefile must match actual tasks. Don’t reference non-existent targets.
- Emit **only** file blocks. Do **not** echo instructions or examples.

BEGIN OUTPUT NOW — FIRST LINE MUST BE A FILE BLOCK.
--- END OF FILE: templates/rust/prompt_templates/generation.tera ---


--- START OF FILE: templates/rust/prompt_templates/review.tera ---
### FILE: templates/rust/prompt_templates/review.tera
{% include "shared/instructions/base_instructions.tera" %}
{% include "shared/instructions/response_format.tera" %}

You are a Principal Rust Engineer specializing in systems programming and performance optimization. You are tasked with **refactoring** a junior developer's code for a production release. The provided code is a first draft and is known to contain inefficiencies and non-idiomatic patterns.

**Your task is not to add new features, but to rewrite the existing code** to be highly performant, idiomatic, safe, and maintainable, following the strict architectural patterns provided. The logical output must remain the same, but the implementation must be replaced with production-grade Rust.

---
### ORIGINAL SPECIFICATION ###
---

Target Language: {{ spec.language }}
Project Type: {{ spec.project_type }}
Project Description: {{ spec.description }}

---
### GENERATED CODE TO REVIEW ###
---

```rust
{{ initial_code }}
```
REFACTORING INSTRUCTIONS

Analyze the GENERATED CODE TO REVIEW. Identify all violations of the NON-NEGOTIABLE REQUIREMENTS and common Rust anti-patterns.

Create a Refactoring Plan: Before writing any code, add a comment block in the src/main.rs or src/lib.rs file outlining your plan. Specifically mention which anti-patterns you identified and how your new implementation will fix them. For example:

Rust
// REFACTORING PLAN
// 1. Identified multiple uses of `.unwrap()`, which can cause panics. These will be replaced with proper error handling using the `anyhow` crate and the `?` operator.
// 2. The original code used manual argument parsing. This will be refactored to use the `clap` crate with the derive macro for robust and idiomatic CLI parsing.
// 3. The error handling was inconsistent. The new implementation will use a unified `anyhow::Result<()>` return type from `main` for clean error propagation.
// 4. Logic was monolithic in `main.rs`. I will extract the core business logic into a separate `lib.rs` to make it a reusable library and improve testability.
Rewrite the Code: Based on your plan, rewrite the files from scratch to be production-ready.

RUST-SPECIFIC REVIEW FOCUS

Error Handling: Replace all uses of .unwrap() and .expect() with Result and the ? operator. Use anyhow for application-level errors.

CLI Parsing: Ensure clap is used correctly with the derive feature for a clean, declarative argument structure.

Idiomatic Code: Use iterators and functional patterns over manual loops where appropriate. Follow standard Rust formatting (rustfmt).

Safety and Performance: Check for unnecessary allocations, cloning, or inefficient algorithms. Ensure proper ownership and borrowing.

Modularity: Separate library logic from the binary entry point (src/lib.rs vs src/main.rs).

Final Instruction: Begin your response immediately with ### FILE:.... Do not include any conversational preamble, summary, or explanation. Your entire response must be only the generated code files. Adhere strictly to this format.
--- END OF FILE: templates/rust/prompt_templates/review.tera ---


--- START OF FILE: templates/shared/README.md.template ---

--- END OF FILE: templates/shared/README.md.template ---


--- START OF FILE: templates/shared/gitignore.template ---

--- END OF FILE: templates/shared/gitignore.template ---
